/**
 * IBM Cloud Object Storage (COS) Adapter
 * Replaces Supabase Storage for IBM Cloud deployment.
 *
 * Files are uploaded/downloaded via signed URLs generated by IBM Cloud Functions,
 * keeping COS credentials server-side only.
 */

import { IBM_CONFIG } from './ibm-config';
import { ibmAuth } from './ibm-auth';

export interface UploadResult {
  path: string;
  publicUrl: string;
  error: Error | null;
}

export interface ListResult {
  files: Array<{ name: string; size: number; lastModified: string; path: string }>;
  error: Error | null;
}

async function getAuthHeaders(): Promise<Record<string, string>> {
  const session = await ibmAuth.getSession();
  return {
    'Content-Type': 'application/json',
    ...(session?.accessToken ? { Authorization: `Bearer ${session.accessToken}` } : {}),
  };
}

class IBMStorageBucket {
  constructor(private bucket: string) {}

  /**
   * Upload a file â€” gets a signed PUT URL from IBM Cloud Functions,
   * then streams the file directly to IBM COS.
   */
  async upload(
    path: string,
    file: File | Blob | ArrayBuffer,
    options?: { contentType?: string; upsert?: boolean; cacheControl?: string }
  ): Promise<UploadResult> {
    try {
      const headers = await getAuthHeaders();
      const baseUrl = IBM_CONFIG.database.functionsBaseUrl;

      // Step 1: Get signed upload URL from backend function
      const signedRes = await fetch(`${baseUrl}/storage-sign`, {
        method: 'POST',
        headers,
        body: JSON.stringify({
          bucket: this.bucket,
          path,
          operation: 'upload',
          contentType: options?.contentType || (file instanceof File ? file.type : 'application/octet-stream'),
          upsert: options?.upsert ?? false,
          cacheControl: options?.cacheControl,
        }),
      });

      if (!signedRes.ok) {
        throw new Error('Failed to get upload URL');
      }

      const { signedUrl, publicUrl } = await signedRes.json();

      // Step 2: Upload directly to IBM COS via signed URL
      const uploadRes = await fetch(signedUrl, {
        method: 'PUT',
        headers: {
          'Content-Type': options?.contentType || (file instanceof File ? file.type : 'application/octet-stream'),
          ...(options?.cacheControl ? { 'Cache-Control': options.cacheControl } : {}),
        },
        body: file,
      });

      if (!uploadRes.ok) {
        throw new Error('COS upload failed');
      }

      return { path, publicUrl, error: null };
    } catch (err) {
      return {
        path,
        publicUrl: '',
        error: err instanceof Error ? err : new Error(String(err)),
      };
    }
  }

  /** Download a file as a Blob via a signed GET URL */
  async download(path: string): Promise<{ data: Blob; error: null } | { data: null; error: Error }> {
    try {
      const headers = await getAuthHeaders();
      const baseUrl = IBM_CONFIG.database.functionsBaseUrl;

      const signedRes = await fetch(`${baseUrl}/storage-sign`, {
        method: 'POST',
        headers,
        body: JSON.stringify({ bucket: this.bucket, path, operation: 'download' }),
      });

      if (!signedRes.ok) throw new Error('Failed to get download URL');
      const { signedUrl } = await signedRes.json();

      const dlRes = await fetch(signedUrl);
      if (!dlRes.ok) throw new Error('COS download failed');

      return { data: await dlRes.blob(), error: null };
    } catch (err) {
      return { data: null, error: err instanceof Error ? err : new Error(String(err)) };
    }
  }

  /** Get a public URL for viewing a file (synchronous) */
  getPublicUrl(path: string): { data: { publicUrl: string } } {
    const cosEndpoint = IBM_CONFIG.cos.endpoint;
    const bucket = this.bucket;
    return {
      data: {
        publicUrl: `https://${bucket}.${cosEndpoint}/${path}`,
      },
    };
  }

  /** Create a signed URL for temporary access */
  async createSignedUrl(path: string, expiresIn: number): Promise<{ data: { signedUrl: string }; error: null } | { data: null; error: Error }> {
    try {
      const headers = await getAuthHeaders();
      const baseUrl = IBM_CONFIG.database.functionsBaseUrl;

      const res = await fetch(`${baseUrl}/storage-sign`, {
        method: 'POST',
        headers,
        body: JSON.stringify({
          bucket: this.bucket,
          path,
          operation: 'download',
          expiresIn,
        }),
      });

      if (!res.ok) throw new Error('Failed to create signed URL');
      const { signedUrl } = await res.json();

      return { data: { signedUrl }, error: null };
    } catch (err) {
      return { data: null, error: err instanceof Error ? err : new Error(String(err)) };
    }
  }

  /** List files in a folder */
  async list(
    folder?: string,
    options?: { limit?: number; offset?: number }
  ): Promise<ListResult> {
    try {
      const headers = await getAuthHeaders();
      const baseUrl = IBM_CONFIG.database.functionsBaseUrl;

      const res = await fetch(`${baseUrl}/storage-list`, {
        method: 'POST',
        headers,
        body: JSON.stringify({
          bucket: this.bucket,
          prefix: folder,
          limit: options?.limit ?? 100,
          offset: options?.offset ?? 0,
        }),
      });

      if (!res.ok) throw new Error('Failed to list files');
      const result = await res.json();
      return { files: result.files, error: null };
    } catch (err) {
      return { files: [], error: err instanceof Error ? err : new Error(String(err)) };
    }
  }

  /** Delete one or more files */
  async remove(paths: string[]): Promise<{ error: Error | null }> {
    try {
      const headers = await getAuthHeaders();
      const baseUrl = IBM_CONFIG.database.functionsBaseUrl;

      const res = await fetch(`${baseUrl}/storage-delete`, {
        method: 'POST',
        headers,
        body: JSON.stringify({ bucket: this.bucket, paths }),
      });

      if (!res.ok) throw new Error('Failed to delete files');
      return { error: null };
    } catch (err) {
      return { error: err instanceof Error ? err : new Error(String(err)) };
    }
  }
}

class IBMStorageClient {
  from(bucket: string): IBMStorageBucket {
    return new IBMStorageBucket(bucket);
  }
}

export const ibmStorage = new IBMStorageClient();
